import re

from collections import OrderedDict

from utils.obs_opt import get_obs_highlight

MAX_POINT_NUM = 20
MAX_SIBLING_NUM = 10

TRACE_FORMAT = """<step-{index}>\n{step_trace}\n</step-{index}>\n"""
INPUTS_FORMAT = """OBSERVATION:\n{observation}\nREASON FOR ACTION:\n{reason}\nACTION:\n{action}"""

# --------------------------- 将json格式嵌套的GUI轨迹数据转化为treeNode结构数据 --------------------------- 

class treeNode(object):
    def __init__(self, action, parent=None, depth=0) -> None:
        self.action = action
        self.parent: "treeNode | None" = parent
        # 用 OrderedDict 保证遍历稳定；键用 id() 保证允许“同 action 多节点”同时存在
        self.children: OrderedDict[int, "treeNode"] = OrderedDict()
        self.depth = depth
        self.trace = ''                     # str, trace, a set of `raw_action`
        self.execute_action = ''            # str, execute action generated by the Policy model
        self.state = None                   # str, generated by the World model
        self.numVisits = 0                  # int, visiting frequency
        self.V = 0                          # float, value of node, generated by the World model
        self.v_desc = ''                    # string, the detailed reasons generated by the reward model
        self.isFullyExpanded = False        # expanded, whether has childnode
        self.isTerminal = False             # value acceptable, whether task finished
        self.thinking = ''                  # string 节点当前的思考过程，//#! 通过请求thinking LLM得到一个response
        self.reflection = ''                # string 节点当前的状态反思，//#! 通过请求reflection LLM得到一个response

    # 便于添加孩子的辅助函数
    def add_child(self, child: "treeNode") -> None:
        self.children[id(child)] = child
        child.parent = self
        child.depth = self.depth + 1
    
    def parse_action_thinking(self):
        """
        从 self.action 文本中提取 thinking 与 action。
        若匹配失败，对应字段返回 ''。
        同时把结果写回 self.thinking 与 self.execute_action，便于后续使用。
        """
        # ---------- 1. 提取 thinking ----------
        think_pat = re.compile(
            r"Let's think step-by-step\.\s*(.*?)\s*In summary, the next action I will perform is",
            flags=re.DOTALL | re.IGNORECASE,
        )
        think_match = think_pat.search(self.action)
        thinking = think_match.group(1).strip() if think_match else ""

        # ---------- 2. 提取 action ----------
        # 先尝试 ```code``` 块；若无，则退化为普通文本模式
        action_pat = re.compile(
            r"In summary, the next action I will perform is\s*```(.*?)```",
            flags=re.DOTALL | re.IGNORECASE,
        )
        action_match = action_pat.search(self.action)
        if action_match:
            action = action_match.group(1).strip()
        else:
            # 备选：抓取 like "click [66]"（直到逗号、句点或换行结束）
            fallback_pat = re.compile(
                r"In summary, the next action I will perform is\s*([A-Za-z]+\s*\[[0-9]+\])",
                flags=re.IGNORECASE,
            )
            fb_match = fallback_pat.search(self.action)
            action = fb_match.group(1).strip() if fb_match else ""
            
        self.thinking = thinking
        self.execute_action = action
        
    def update_trace_from_parent(self):
        if self.parent is None:
            self.trace = ''
        else:
            self.parse_action_thinking() 
            summary_content = get_obs_highlight(
                action_str=self.execute_action,
                a11y_data=self.parent.state,
                sample_strategy='nearest'
            )
            step_trace = INPUTS_FORMAT.format(
                observation=summary_content,
                reason=self.thinking,
                action=self.execute_action
            )            
            self.trace = self.parent.trace + TRACE_FORMAT.format(
                index=self.parent.depth, step_trace=step_trace
            )

    def get_visible_node_number(self):
        visible_ids = []

        def dfs(current_node: treeNode):
            if current_node.action:
                visible_ids.append(current_node.action)
            for child in current_node.children.values():
                dfs(child)

        dfs(self)

        return len(visible_ids)

def build_tree_from_json(json_data, parent=None, depth=0):
    # 创建当前节点
    node = treeNode(
        action=json_data.get('action', ''), 
        parent=parent, 
        depth=json_data.get("depth", parent.depth + 1 if parent else 0)
    )
    # 设置节点属性
    node.state = json_data.get('state', '')
    node.depth = json_data.get('depth', '')
    node.thinking = json_data.get('thinking', '')
    node.execute_action = json_data.get('execute_action', '')
    node.numVisits = json_data.get('numVisits', 0)
    node.V = json_data.get('V', 0.0)
    node.v_desc = json_data.get('v_desc', 0.0)
    node.isTerminal = json_data.get('isTerminal', False)
    node.update_trace_from_parent()
    
    # 递归处理子节点
    children_raw = json_data.get('children', {})
    # 支持 2 种常见格式：dict 或 list
    if isinstance(children_raw, dict):
        iterable = children_raw.values()          # 忽略 dict 键，保持顺序
    elif isinstance(children_raw, list):
        iterable = children_raw
    else:
        iterable = []                             # 其他类型一律视为无子节点
    
    for child_data in iterable:
        # 过滤掉 state 过短的子节点（可能是状态生成中存在的错误）
        state = child_data.get('state', '')
        if not state:
            continue
        elif len(state) < 100:
            continue
        
        child_node = build_tree_from_json(child_data, parent=node)
        node.add_child(child_node)
    
    # 判断节点是否扩展
    node.isFullyExpanded = True if len(list(iterable)) > 0 else False
    
    return node

